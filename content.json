{"meta":{"title":"Dynamic_Pigeon","subtitle":null,"description":"好少年光芒万丈","author":"Dynamic_Pigeon","url":"https://chy669086.github.io"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"client/index.html","permalink":"https://chy669086.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2024-10-01T14:14:36.000Z","updated":"2024-10-02T08:53:15.676Z","comments":false,"path":"about/index.html","permalink":"https://chy669086.github.io/about/index.html","excerpt":"","text":"[Dynamic_Pigeon の秘密对话] 与&nbsp; Dynamic_Pigeon&nbsp; 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2024-10-08T14:32:31.230Z","comments":true,"path":"comment/index.html","permalink":"https://chy669086.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"donate/index.html","permalink":"https://chy669086.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"bangumi/index.html","permalink":"https://chy669086.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"lab/index.html","permalink":"https://chy669086.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2024-09-30T16:15:47.829Z","comments":true,"path":"links/index.html","permalink":"https://chy669086.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"music/index.html","permalink":"https://chy669086.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2024-09-30T16:15:47.829Z","comments":true,"path":"tags/index.html","permalink":"https://chy669086.github.io/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://chy669086.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2024-09-30T16:15:47.829Z","comments":true,"path":"rss/index.html","permalink":"https://chy669086.github.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-09-30T16:15:47.829Z","comments":false,"path":"video/index.html","permalink":"https://chy669086.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"2024 秋冬季开源操作系统训练营学习笔记","slug":"2024-秋冬季开源操作系统训练营学习笔记","date":"2024-10-09T13:07:47.000Z","updated":"2024-10-09T14:59:12.494Z","comments":true,"path":"2024/10/09/2024-秋冬季开源操作系统训练营学习笔记/","link":"","permalink":"https://chy669086.github.io/2024/10/09/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"个人 Rust 开源训练营学习笔记，大概会隔一段时间更新一次 &gt2024-10-92024-10-9 一上来第一件事就是抛开了 rust 标准库。我应该能想到的，毕竟标准库需要依赖系统，但是 OS Camp 要开发一个系统。这下轮子都要自己造了。 我不会 RISV-V 汇编啊！ 训练营用的是 Qemu7.0 模拟器模拟环境。rust 编译使用 riscv64gc-unknown-none-elf 编译环境 注解riscv64gc-unknown-none-elf 的 CPU 架构是 riscv64gc，厂商是 unknown，操作系统是 none， elf 表示没有标准的运行时库。没有任何系统调用的封装支持，但可以生成 ELF 格式的执行程序。 我们不选择有 linux-gnu 支持的 riscv64gc-unknown-linux-gnu，是因为我们的目标是开发操作系统内核，而非在 linux 系统上运行的应用程序。 在加入编译命令 riscv64gc-unknown-none-elf 后再在 main.rs 加入 #![no_std] 后，如果在 vsc 使用 rust-analyzer 的时候会出现 Can&#39;t find crete test 的报错，但是程序又是没有问题的，这是一个 bug，官方 issue。 只要在 vsc 的 settings.json 加入以下内容就行了 { \"rust-analyzer.checkOnSave.allTargets\": false, \"rust-analyzer.checkOnSave.extraArgs\": [ \"--target\", \"riscv64gc-unknown-none-elf\" ] } 以及训练营给出的解答： { // Prevent \"can't find crate for `test`\" error on no_std // Ref: https://github.com/rust-lang/vscode-rust/issues/729 // For vscode-rust plugin users: \"rust.target\": \"riscv64gc-unknown-none-elf\", \"rust.all_targets\": false, // For Rust Analyzer plugin users: \"rust-analyzer.cargo.target\": \"riscv64gc-unknown-none-elf\", \"rust-analyzer.checkOnSave.allTargets\": false, // \"rust-analyzer.cargo.features\": [ // \"board_qemu\" // ] } 实验是在裸机平台上进行的（这不是放屁吗，os 还能在哪里跑）。 看见那些中断和汇编调用，我已经要去世了 api 与 abi 的区别 说真的之前都不知道有 abi 这个东西。 API Application Programming Interface ABI Application Binary Interface 简单来说，ABI 就是二进制接口，来自系统底层，所有程序都可以通过遵守 ABI 来调用；API 一般局限在一个编程语言，定义了源码级别的操作。 训练营给的解释API 与 ABI 的区别应用程序二进制接口 ABI 是不同二进制代码片段的连接纽带。ABI 定义了二进制机器代码级别的规则，主要包括基本数据类型、通用寄存器的使用、参数的传递规则、以及堆栈的使用等等。ABI 与处理器和内存地址等硬件架构相关，是用来约束链接器 (Linker) 和汇编器 (Assembler) 的。在同一处理器下，基于不同高级语言编写的应用程序、库和操作系统，如果遵循同样的 ABI 定义，那么它们就能正确链接和执行。应用程序编程接口 API 是不同源代码片段的连接纽带。API 定义了一个源码级（如 C 语言）函数的参数，参数的类型，函数的返回值等。因此 API 是用来约束编译器 (Compiler) 的：一个 API 是给编译器的一些指令，它规定了源代码可以做以及不可以做哪些事。API 与编程语言相关，如 libc 是基于 C 语言编写的标准库，那么基于 C 的应用程序就可以通过编译器建立与 libc 的联系，并能在运行中正确访问 libc 中的函数。link &gt2024-10-82024-10-8 上学期第一次了解到 rust 语言。第一次听到 rust 是来自他的外号“语言神”（原神启动！），以及了解到 rust 的最大特色：编译错误。 学习了一段时间后，感觉 rust 是真**的优雅，所有权、生命周期、借用规则让我醍醐灌顶。也让我把这套规则移动到了其他语言使用，也是大大加速了我的编写速度。 学习阶段去写了 rustling、mini-lsm 开源学习项目（mini-lsm week3 开头给我干爆炸了就没有继续写下去）。 感觉还是不是很深得 rust 开发的精髓。写起来 C 里 C 气。感觉取悦编译器也是一门技术活（最经典的 rust 序列访问会生成 assert，所以可以提前 assert 减少 assert 次数）。 cargo 是世界上最好的包管理器！ 感谢 Rust语言圣经(Rust Course)、Rust 程序设计语言 和其他网络上的作者贡献的大量的学习资源。 现开源训练营一阶段晋级。（牛魔的 unsafe 链表真是依托） 顺便吐槽一下 C++ 那依托的 tuple","categories":[{"name":"笔记","slug":"笔记","permalink":"https://chy669086.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"2024 秋冬季开源操作系统训练营","slug":"2024-秋冬季开源操作系统训练营","permalink":"https://chy669086.github.io/tags/2024-%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/"},{"name":"Rust","slug":"Rust","permalink":"https://chy669086.github.io/tags/Rust/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://chy669086.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://chy669086.github.io/categories/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++ CRTR 简介","slug":"C-CRTR-简介","date":"2024-10-05T14:08:24.000Z","updated":"2024-10-08T14:13:41.396Z","comments":true,"path":"2024/10/05/C-CRTR-简介/","link":"","permalink":"https://chy669086.github.io/2024/10/05/C-CRTR-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"最近看群友讨论到了“虚函数就是历史遗留问题，现在完全可以用 CRTR 代替”，好奇，就去搜索了什么是 CRTR，结果发现这么早的一个技术我现在才知道，真是落后时代 10 余年。 虚函数与动态链接C++ 的多态是通过虚函数实现的，虚函数的实质是在对象中开辟了一个空间来存储函数指针（虚函数表 vtable），调用这个函数是通过这个指针去访问，而不能在编译期确定。 比如： class Animal &#123; public: virtual void jump() = 0; &#125;; class Cat : public Animal &#123; public: void jump() override &#123; std::cout &lt;&lt; &quot;cat jump\\n&quot;; &#125; &#125;; int main() &#123; Animal *p = new Cat; p-&gt;jump(); return 0; &#125; 调用 p-&gt;jump() 的时候，程序会去虚函数表寻找那个指针，在这个程序中最终会调用 Cat::jump()。 但是查表终究是有代价的，有没有兼顾多态和效率的做法呢，于是，CRTR(Curiously Recurring Template Pattern) 应运而生。 通过模板实现静态绑定首先复习一个概念，C++ 的模板是编译期多态，是零成本抽象。我们在子类和父类中定义同一个函数，但是不声明为虚函数，通过编译期多态来实现绑定。 template &lt;typename T&gt; class Base &#123; public: void show() const &#123; static_cast&lt;const T*&gt;(this)-&gt;show(); &#125; &#125;; class Driver : public Base&lt;Driver&gt; &#123; public: void show() const &#123; std::cout &lt;&lt; &quot;This is class Driver.&quot; &lt;&lt; std::endl; &#125; &#125;; int main() &#123; Base&lt;Driver&gt; *p = new Driver; p-&gt;show(); return 0; &#125; 这是一个简单的例子，有下列特点 基类是模板类，用来接收子类的名字，因此继承类似于 ClassName : public Base&lt;ClassName&gt;。 基类的函数中，用 static_cast&lt;&gt; 将基类的指针转换成子类的指针实现绑定。 运行上述程序，得到结果 This is class Driver. 说明我们成功进行了子类与父类的绑定，实打实的调用了子类的 show() 函数。 有什么用，怎么用众所周知，多态一般需要类似 std::vector&lt;Base*&gt; 的形式，但是由于我们的基类是模板类，不能通过这种方式多态，不如说，没有多态，因为 Animal&lt;Cat&gt;* 和 Animal&lt;Dog&gt;* 是两个完全不同的指针。 那怎么办？ 考虑到一次查表的开销不是特别大，虚函数带来的大量开销主要是多层继承带来的巨大链条带来的查询开销，继承链很短的话开销其实是在预期内的。 那我们用一个模板基类继承一个普通基类，这个普通基类使用虚函数，但是模板基类使用静态绑定，派生类去继承这个模板基类，那么不论如何，我们都只需要查一次表就可以定位到对应的函数，大大降低了多次继承带来的开销。 class Animal &#123; public: virtual void say() const = 0; virtual ~Animal() &#123;&#125; &#125;; template &lt;typename T&gt; class Animal_CRTR : public Animal &#123; public: void say() const override &#123; static_cast&lt;const T*&gt;(this)-&gt;say(); &#125; &#125;; class Cat : public Animal_CRTR&lt;Cat&gt; &#123; public: void say() const &#123; std::cout &lt;&lt; &quot;I&#39;m a cat.\\n&quot;; &#125; &#125;; class Dog : public Animal_CRTR&lt;Dog&gt; &#123; public: void say() const &#123; std::cout &lt;&lt; &quot;I&#39;m a dog.\\n&quot;; &#125; &#125;; int main() &#123; std::vector&lt;Animal*&gt; v; v.push_back(new Dog); v.push_back(new Cat); for (auto x : v) &#123; x-&gt;say(); &#125; return 0; &#125; 输出结果 I&#39;m a dog. I&#39;m a cat. 不过写起来确实很麻烦，而且没有 override 带来的部分编译提示（字打错了跑哪里哭去），但是这样写我们同时赢得了多态和效率（同时代码量极致膨胀）。 为什么有人还在用继承啊","categories":[{"name":"技术","slug":"技术","permalink":"https://chy669086.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chy669086.github.io/tags/C/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://chy669086.github.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"2022 ICPC 杭州区域赛 K 题题解","slug":"2022-ICPC-杭州区域赛-K-题题解","date":"2024-10-02T09:01:08.000Z","updated":"2024-10-08T13:03:11.570Z","comments":true,"path":"2024/10/02/2022-ICPC-杭州区域赛-K-题题解/","link":"","permalink":"https://chy669086.github.io/2024/10/02/2022-ICPC-%E6%9D%AD%E5%B7%9E%E5%8C%BA%E5%9F%9F%E8%B5%9B-K-%E9%A2%98%E9%A2%98%E8%A7%A3/","excerpt":"","text":"题目大意给你 $n$ 个字符串，然后有 $q$ 次询问，每次询问给出一个字典序，请你输出在这个字典序下的逆序对个数。 题解首先考虑暴力，每次询问可以 $O(|S|\\log(n))$ 处理，显然会超时。 考虑优化，注意到两个字符串比较出结果一定是在某个位置发生的（称这个比出大小的比较为决定性比较），这两个字符串一定有一个相同的前缀（长度可能是 0）。那么可以把问题转换成判断某个字符和其他字符发生了几次决定性的的比较，那么对于每次询问我们和 $O(26 \\times 26)$ 处理。 如何找到发生了几次决定性的比较呢，注意前面的一个性质，决定性比较之前的两个字符串一定是同前缀，这正好撞上了字典树的性质：相同前缀共用一条链。 我们只要统计每个节点的后继节点字符总数，就可以对每一个新插入的字符串进行决定性比较的统计。对于 a 和 aa 这种串，我们可以简单在每个串后面加一个字符，并人为将这个字符的字典序设置为最小 // 字段树节点 struct node &#123; // 后继节点位置 std::array&lt;int, 27&gt; nxt; // 后继节点个数统计 std::array&lt;int, 27&gt; sum; node() &#123; std::fill(all(nxt), -1); std::fill(all(sum), 0); &#125; &#125;; // 决定性比较次数统计 int cnt[27][27]; struct Trie &#123; std::vector&lt;node&gt; nodes; int root = 0; Trie() &#123; nodes.emplace_back(); &#125; void insert(const std::string &amp;s) &#123; int cur = root; for (char c : s) &#123; if (nodes[cur].nxt[c - &#39;a&#39;] == -1) &#123; nodes[cur].nxt[c - &#39;a&#39;] = nodes.size(); nodes.emplace_back(); &#125; // 统计这个串的这个位置决定性比较次数 for (int i = 0; i &lt; 27; i++) &#123; cnt[c - &#39;a&#39;][i] += nodes[cur].sum[i]; &#125; // 后继节点计数加一 nodes[cur].sum[c - &#39;a&#39;]++; cur = nodes[cur].nxt[c - &#39;a&#39;]; &#125; &#125; &#125;; 全部代码 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;cassert&gt; #include &lt;cctype&gt; #include &lt;cmath&gt; #include &lt;cstdint&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;ostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #ifdef DYNAMIC_PIGEON #include &quot;algo/debug.h&quot; #else #define debug(...) 114514 #endif #define Dynamic_Pigeon 0 using i64 = std::int64_t; using u64 = std::uint64_t; using u32 = std::uint32_t; constexpr i64 MOD = i64(1e9) + 7; constexpr int INF = 1e9; constexpr i64 INF_LONG_LONG = 1e18; #define all(a) a.begin(), a.end() #define rall(a) a.rbegin(), a.rend() #define int i64 struct node &#123; std::array&lt;int, 27&gt; nxt; std::array&lt;int, 27&gt; sum; node() &#123; std::fill(all(nxt), -1); std::fill(all(sum), 0); &#125; &#125;; int cnt[27][27]; struct Trie &#123; std::vector&lt;node&gt; nodes; int root = 0; Trie() &#123; nodes.emplace_back(); &#125; void insert(const std::string &amp;s) &#123; int cur = root; for (char c : s) &#123; if (nodes[cur].nxt[c - &#39;a&#39;] == -1) &#123; nodes[cur].nxt[c - &#39;a&#39;] = nodes.size(); nodes.emplace_back(); &#125; for (int i = 0; i &lt; 27; i++) &#123; cnt[c - &#39;a&#39;][i] += nodes[cur].sum[i]; &#125; nodes[cur].sum[c - &#39;a&#39;]++; cur = nodes[cur].nxt[c - &#39;a&#39;]; &#125; &#125; &#125;; void tizzytyt_SuKi() &#123; int n, q; std::cin &gt;&gt; n &gt;&gt; q; Trie trie; for (int i = 0; i &lt; n; i++) &#123; std::string s; std::cin &gt;&gt; s; s.push_back(&#39;a&#39; + 26); trie.insert(s); &#125; while (q--) &#123; std::string s; std::cin &gt;&gt; s; s = (char)(&#39;a&#39; + 26) + s; i64 ans = 0; for (int i = 0; i &lt; 27 - 1; i++) &#123; for (int j = i + 1; j &lt; 27; j++) &#123; ans += cnt[s[i] - &#39;a&#39;][s[j] - &#39;a&#39;]; &#125; &#125; std::cout &lt;&lt; ans &lt;&lt; &#39;\\n&#39;; &#125; &#125; signed main() &#123; #ifdef DYNAMIC_PIGEON freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); #else std::cin.tie(0)-&gt;sync_with_stdio(0); #endif tizzytyt_SuKi(); return Dynamic_Pigeon; &#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://chy669086.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chy669086.github.io/tags/C/"},{"name":"ICPC","slug":"ICPC","permalink":"https://chy669086.github.io/tags/ICPC/"},{"name":"题解","slug":"题解","permalink":"https://chy669086.github.io/tags/%E9%A2%98%E8%A7%A3/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://chy669086.github.io/categories/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++ search 函数","slug":"C-search-函数","date":"2024-10-01T12:34:15.000Z","updated":"2024-10-08T13:03:11.570Z","comments":true,"path":"2024/10/01/C-search-函数/","link":"","permalink":"https://chy669086.github.io/2024/10/01/C-search-%E5%87%BD%E6%95%B0/","excerpt":"","text":"简介std::search 函数在 C++ 很早的版本就开始存在了，但是在 C++17 中添加了一些重载和辅助类，这大大提高了这个函数的使用价值。这篇文章主要来介绍下面这个重载。 template&lt; class ForwardIt, class Searcher &gt; ForwardIt search( ForwardIt first, ForwardIt last, const Searcher&amp; searcher ); 元素名称 元素意义 first, last 要检验的元素范围 —— 一般是迭代器 searcher 封装搜索算法和搜索模式的搜索器 这是从 C++17 开始给 std::search 添加的函数重载，Searcher 是搜索器，接下来就是这个函数最有用的地方了，C++ std 提供了三种搜索器： default_searcher (C++17) 标准 C++ 库搜索算法实现 boyer_moore_searcher (C++17) Boyer-Moore 搜索算法实现 boyer_moore_horspool_searcher (C++17) Boyer-Moore-Horspool 搜索算法实现 注意到标准库提供了 BM 算法的搜索器，BM 算法一直被称为最快的字符串搜索算法，在实际表现中一般比 KMP 快 2～3 倍（暴力算法在大部分时候其实表现也比 KMP 好）。但是由于 BM 算法的最坏时间复杂度是 $O(nm)$，所以不建议在算法竞赛中使用，但是在生产环境中，BM 算法无疑是最佳选择。 使用举例#include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() &#123; std::string s = &quot;never&quot;; // 用 s 创建一个搜索器 std::boyer_moore_searcher searcher(s.begin(), s.end()); std::string text = &quot;never say never&quot;; // 在 text 中搜索 s auto result = std::search(text.begin(), text.end(), searcher); if (result != text.end()) &#123; std::cout &lt;&lt; &quot;The text contains the substring \\&quot;never\\&quot; at position &quot; &lt;&lt; result - text.begin() &lt;&lt; &#39;\\n&#39;; &#125; else &#123; std::cout &lt;&lt; &quot;The text does not contain the substring \\&quot;never\\&quot;\\n&quot;; &#125; // 在另一个文本中搜索 s text = &quot;always say always&quot;; result = std::search(text.begin(), text.end(), searcher); if (result != text.end()) &#123; std::cout &lt;&lt; &quot;The text contains the substring \\&quot;never\\&quot; at position &quot; &lt;&lt; result - text.begin() &lt;&lt; &#39;\\n&#39;; &#125; else &#123; std::cout &lt;&lt; &quot;The text does not contain the substring \\&quot;never\\&quot;\\n&quot;; &#125; return 0; &#125; 输出结果 The text contains the substring &quot;never&quot; at position 0 The text does not contain the substring &quot;never&quot; 参考链接cppreferrence.com","categories":[{"name":"技术","slug":"技术","permalink":"https://chy669086.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://chy669086.github.io/tags/C/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://chy669086.github.io/categories/%E6%8A%80%E6%9C%AF/"}]}]}