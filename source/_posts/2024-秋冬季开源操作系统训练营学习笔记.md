---
title: 2024 秋冬季开源操作系统训练营学习笔记
author: Dynamic_Pigeon
avatar: https://s3.bmp.ovh/imgs/2024/10/08/ca40e9bf152dbbf0.jpg
authorLink: chy669086.github.io
authorAbout: 一个好奇的人
authorDesc: 一个好奇的人
categories: 笔记
comments: true
date: 2024-10-08 21:07:47
updated: 2024-10-12 20:52:34
tags:
    - 2024 秋冬季开源操作系统训练营
    - Rust
    - 学习笔记
keywords:
description:
    个人学习笔记
photos: https://s3.bmp.ovh/imgs/2024/10/08/14b0416bb5096fb3.jpeg
---
个人 Rust 开源训练营学习笔记（感觉更像日记），大概会隔一段时间更新一次

## 2024-10-12

{% collapsecard  %}
ch3 在昨天看了一天才看懂要干什么~~我好菜啊~~

ch3 写完后本地单独测试都能过，但是一起测试就会起飞，debug 后发现 `get_time()` 函数一直输出的是 0。群内老哥说应该是 sbi 的问题，我也不懂我也不知道啊（x

然后我就重构了一下，我然后就写了一个很~~弱智~~的代码，重现一下大概是这个感觉：

```rust
use std::cell::RefCell;

fn main() {
    let task = Task::new(1);
    println!("Task id: {}", task.get_id());
}

struct TaskInner {
    arr: [u32; 10],
    id: usize,
}

struct Task {
    inner: RefCell<TaskInner>,
}

impl Task {
    fn get_id(&self) -> u32 {
        self.inner.borrow_mut().arr[self.inner.borrow_mut().id]
    }

    fn new(id: u32) -> Task {
        Task {
            inner: RefCell::new(TaskInner {
                arr: [id; 10],
                id: 0,
            }),
        }
    }
}
```

`self.inner.borrow_mut().arr[self.inner.borrow_mut().id]` 直接借用两次直接起飞（

**警钟撅烂**

ch3 我的实现十分的垃圾，感觉性能完全不行（

ch4 直接告诉我要重写（

~~杀了我算了~~

{% endcollapsecard %}

## 2024-10-9

{% collapsecard  %}
一上来第一件事就是抛开了 rust 标准库。我应该能想到的，毕竟标准库需要依赖系统，但是 OS Camp 要开发一个系统。这下轮子都要自己造了。

~~我不会 RISV-V 汇编啊！~~

训练营用的是 Qemu7.0 模拟器模拟环境。rust 编译使用 `riscv64gc-unknown-none-elf` 编译环境

!!! note 注解
    riscv64gc-unknown-none-elf 的 CPU 架构是 riscv64gc，厂商是 unknown，操作系统是 none， elf 表示没有标准的运行时库。没有任何系统调用的封装支持，但可以生成 ELF 格式的执行程序。 我们不选择有 linux-gnu 支持的 riscv64gc-unknown-linux-gnu，是因为我们的目标是开发操作系统内核，而非在 linux 系统上运行的应用程序。

在加入编译命令 `riscv64gc-unknown-none-elf` 后再在 `main.rs` 加入 `#![no_std]` 后，如果在 vsc 使用 rust-analyzer 的时候会出现 `Can't find crete test`  的报错，但是程序又是没有问题的，这是一个 bug，官方 [issue](https://github.com/rust-lang/vscode-rust/issues/729)。

只要在 vsc 的 settings.json 加入以下内容就行了

```json
{
    "rust-analyzer.checkOnSave.allTargets": false,
    "rust-analyzer.checkOnSave.extraArgs": [
            "--target",
            "riscv64gc-unknown-none-elf"
    ]
}
```

以及训练营给出的解答：

```json
{
    // Prevent "can't find crate for `test`" error on no_std
    // Ref: https://github.com/rust-lang/vscode-rust/issues/729
    // For vscode-rust plugin users:
    "rust.target": "riscv64gc-unknown-none-elf",
    "rust.all_targets": false,
    // For Rust Analyzer plugin users:
    "rust-analyzer.cargo.target": "riscv64gc-unknown-none-elf",
    "rust-analyzer.checkOnSave.allTargets": false,
    // "rust-analyzer.cargo.features": [
    //     "board_qemu"
    // ]
}
```

实验是在裸机平台上进行的（这不是放屁吗，os 还能在哪里跑）。

看见那些中断和汇编调用，我已经要去世了

**api 与 abi 的区别**

说真的之前都不知道有 abi 这个东西。

|||
|-|-|
|API|Application Programming Interface|
|ABI| Application Binary Interface|

简单来说，ABI 就是二进制接口，来自系统底层，所有程序都可以通过遵守 ABI 来调用；API 一般局限在一个编程语言，定义了源码级别的操作。

!!! info 训练营给的解释
    **API 与 ABI 的区别**
    应用程序二进制接口 ABI 是不同二进制代码片段的连接纽带。ABI 定义了二进制机器代码级别的规则，主要包括基本数据类型、通用寄存器的使用、参数的传递规则、以及堆栈的使用等等。ABI 与处理器和内存地址等硬件架构相关，是用来约束链接器 (Linker) 和汇编器 (Assembler) 的。在同一处理器下，基于不同高级语言编写的应用程序、库和操作系统，如果遵循同样的 ABI 定义，那么它们就能正确链接和执行。
    应用程序编程接口 API 是不同源代码片段的连接纽带。API 定义了一个源码级（如 C 语言）函数的参数，参数的类型，函数的返回值等。因此 API 是用来约束编译器 (Compiler) 的：一个 API 是给编译器的一些指令，它规定了源代码可以做以及不可以做哪些事。API 与编程语言相关，如 libc 是基于 C 语言编写的标准库，那么基于 C 的应用程序就可以通过编译器建立与 libc 的联系，并能在运行中正确访问 libc 中的函数。
    [link](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/2os-interface.html#apiabi)

{% endcollapsecard %}


## 2024-10-8

{% collapsecard %}
上学期第一次了解到 rust 语言。第一次听到 rust 是来自他的外号“语言神”（原神启动！），以及了解到 rust 的最大特色：**编译错误**。

学习了一段时间后，感觉 rust 是真\*\*的优雅，所有权、生命周期、借用规则让我醍醐灌顶。也让我把这套规则移动到了其他语言使用，也是大大加速了我的编写速度。

学习阶段去写了 [rustling](https://github.com/rust-lang/rustlings)、[mini-lsm](https://github.com/skyzh/mini-lsm) 开源学习项目（mini-lsm week3 开头给我干爆炸了就没有继续写下去）。

感觉还是不是很深得 rust 开发的精髓。写起来 C 里 C 气。感觉取悦编译器也是一门技术活（最经典的 rust 序列访问会生成 assert，所以可以提前 assert 减少 assert 次数）。

~~cargo 是世界上最好的包管理器！~~

感谢 [Rust语言圣经(Rust Course)](https://course.rs/about-book.html)、[Rust 程序设计语言](https://www.rustwiki.org.cn/zh-CN/book/) 和其他网络上的作者贡献的大量的学习资源。

现开源训练营一阶段晋级。（牛魔的 unsafe 链表真是依托）

~~顺便吐槽一下 C++ 那依托的 tuple~~
{% endcollapsecard %}
